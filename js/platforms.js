// –ö–ª–∞—Å—Å –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø
console.log('üîß Loading Platform classes...');

class Platform {
    constructor(x, y, type = 'normal') {
        this.x = x;
        this.y = y;
        this.width = 70;
        this.height = 20;
        this.type = type;
        
        if (this.type === 'moving') {
            this.velocityX = (Math.random() - 0.5) * 1.5;
            this.movingRange = 80 + Math.random() * 40;
            this.startX = x;
        }
        
        if (this.type === 'breaking') {
            this.breaking = false;
            this.breakProgress = 0;
            this.breakTimer = 0;
        }
        
        this.lastCollisionTime = 0;
        this.collisionCount = 0;
        
        console.log(`‚ûï Created ${type} platform at (${Math.round(x)}, ${Math.round(y)})`);
    }

    update(deltaTime) {
        if (this.type === 'moving') {
            this.x += this.velocityX;
            
            if (Math.abs(this.x - this.startX) > this.movingRange) {
                this.velocityX *= -1;
            }
        }
        
        if (this.type === 'breaking' && this.breaking) {
            this.breakTimer += deltaTime;
            this.breakProgress = this.breakTimer / 0.5;
            
            // –í–°–ï–ì–î–ê –≤–æ–∑–≤—Ä–∞—â–∞–µ–º true - –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è –¥–∞–∂–µ –ø–æ—Å–ª–µ —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è
            // if (this.breakProgress >= 1) {
            //     console.log('üí• Platform destroyed');
            //     return false;
            // }
            
            // –í–º–µ—Å—Ç–æ —É–¥–∞–ª–µ–Ω–∏—è, –ø—Ä–æ—Å—Ç–æ –æ—Ç–º–µ—á–∞–µ–º –∫–∞–∫ —Ä–∞–∑—Ä—É—à–µ–Ω–Ω—É—é
            if (this.breakProgress >= 1) {
                console.log('üí• Platform fully broken (but kept for reference)');
            }
        }
        
        return true; // –í–°–ï–ì–î–ê –≤–æ–∑–≤—Ä–∞—â–∞–µ–º true - –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —É–¥–∞–ª—è—é—Ç—Å—è
    }

    draw(ctx, assets) {
        const alpha = this.breaking ? 1 - this.breakProgress : 1;
        
        ctx.save();
        ctx.globalAlpha = alpha;
        
        let imageName;
        switch(this.type) {
            case 'breaking':
                imageName = 'platformBreaking';
                break;
            case 'moving':
                imageName = 'platformMoving';
                break;
            default:
                imageName = 'platformNormal';
        }
        
        const image = assets.getImage(imageName);
        
        if (image) {
            ctx.drawImage(image, this.x, this.y, this.width, this.height);
        } else {
            this.drawFallback(ctx);
        }
        
        ctx.restore();
        
        // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
        if (window.DEBUG_MODE) {
            ctx.strokeStyle = this.type === 'breaking' ? 'red' : 'green';
            ctx.lineWidth = 1;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
    }

    drawFallback(ctx) {
        let color;
        switch(this.type) {
            case 'breaking':
                color = '#F39C12';
                break;
            case 'moving':
                color = '#9B59B6';
                break;
            default:
                color = '#2ECC71';
        }
        
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.strokeStyle = this.darkenColor(color, 20);
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        
        // –¢–µ–∫—Å—Ç –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        if (window.DEBUG_MODE) {
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText(`${Math.round(this.y)}`, this.x + 5, this.y + 12);
        }
    }

    collidesWith(player, currentTime) {
        const timeSinceCollision = currentTime - this.lastCollisionTime;
        if (timeSinceCollision < 300) {
            return false;
        }
        
        const playerBottom = player.y + player.height;
        const playerFalling = player.velocityY > 0;
        
        const isColliding = 
            player.x < this.x + this.width &&
            player.x + player.width > this.x &&
            playerBottom >= this.y &&
            playerBottom <= this.y + 10 &&
            playerFalling;
        
        if (isColliding) {
            this.lastCollisionTime = currentTime;
            this.collisionCount++;
            console.log(`üéØ Collision with platform at Y: ${this.y}`);
            return true;
        }
        
        return false;
    }

    startBreaking() {
        if (this.type === 'breaking' && !this.breaking) {
            this.breaking = true;
            this.breakTimer = 0;
            console.log('üü° Breaking platform activated');
            return true;
        }
        return false;
    }

    darkenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return "#" + (0x1000000 + (R * 0x10000) + (G * 0x100) + B).toString(16).slice(1);
    }
}

class PlatformManager {
    constructor() {
        console.log('üîß Initializing PlatformManager');
        this.platforms = [];
        this.scrollY = 0;
        this.highestPoint = 0;
        this.totalPlatformsGenerated = 0;
        this.maxPlatforms = 100; // –£–≤–µ–ª–∏—á–∏–ª–∏ –ª–∏–º–∏—Ç
        this.lastGenerationHeight = 0;
        this.generationThreshold = 20000; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ–≤—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º
        this.generateInitialPlatforms();
    }

    generateInitialPlatforms() {
        console.log('üèóÔ∏è Generating initial platforms');
        
        // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        this.platforms = [];
        
        // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
        const startPlatform = new Platform(360 / 2 - 70 / 2, 500, 'normal');
        this.platforms.push(startPlatform);
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –í–í–ï–†–• –æ—Ç —Å—Ç–∞—Ä—Ç–æ–≤–æ–π
        let currentY = 500;
        const platformsToGenerate = 50; // –£–≤–µ–ª–∏—á–∏–ª–∏ –Ω–∞—á–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        
        for (let i = 0; i < platformsToGenerate; i++) {
            currentY -= this.getRandomGap();
            this.generatePlatform(currentY);
            
            // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
            if (currentY < -10000) break;
        }
        
        this.lastGenerationHeight = this.getHighestPlatform()?.y || currentY;
        this.highestPoint = this.lastGenerationHeight;
        
        console.log(`‚úÖ Generated ${this.platforms.length} platforms`);
        console.log(`üìä Highest platform: ${this.lastGenerationHeight}`);
        console.log('üìà Platform distribution:', this.getPlatformDistribution());
    }
    
    // –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
    getPlatformDistribution() {
        const ranges = {
            '500+': 0,
            '400-500': 0,
            '300-400': 0, 
            '200-300': 0,
            '100-200': 0,
            '0-100': 0,
            'below-0': 0,
            'below-1000': 0,
            'below-2000': 0,
            'below-3000': 0
        };
        
        this.platforms.forEach(platform => {
            const y = platform.y;
            if (y >= 500) ranges['500+']++;
            else if (y >= 400) ranges['400-500']++;
            else if (y >= 300) ranges['300-400']++;
            else if (y >= 200) ranges['200-300']++;
            else if (y >= 100) ranges['100-200']++;
            else if (y >= 0) ranges['0-100']++;
            else if (y >= -1000) ranges['below-0']++;
            else if (y >= -2000) ranges['below-1000']++;
            else if (y >= -3000) ranges['below-2000']++;
            else ranges['below-3000']++;
        });
        
        return ranges;
    }

    generatePlatform(y) {
        if (this.platforms.length >= this.maxPlatforms) {
            this.removeLowestPlatform();
        }
        
        const type = this.getRandomPlatformType();
        const x = this.getRandomPlatformX();
        
        const platform = new Platform(x, y, type);
        this.platforms.push(platform);
        this.totalPlatformsGenerated++;
        
        return platform;
    }

    // –û–±–Ω–æ–≤–∏—Ç–µ –º–µ—Ç–æ–¥ removeLowestPlatform - —Å–¥–µ–ª–∞–π—Ç–µ –µ–≥–æ –±–µ–∑–æ–ø–∞—Å–Ω—ã–º
    removeLowestPlatform() {
        if (this.platforms.length <= 100) return; // –ú–∏–Ω–∏–º—É–º 100 –ø–ª–∞—Ç—Ñ–æ—Ä–º
        
        let lowestIndex = -1;
        let lowestY = -Infinity;
        
        for (let i = 0; i < this.platforms.length; i++) {
            if (this.platforms[i].y > lowestY) {
                lowestY = this.platforms[i].y;
                lowestIndex = i;
            }
        }
        
        if (lowestIndex !== -1 && lowestY > 800) { // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –æ—á–µ–Ω—å –Ω–∏–∑–∫–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            this.platforms.splice(lowestIndex, 1);
        }
    }

    getRandomPlatformType() {
        const rand = Math.random();
        if (rand <= 0.7) return 'normal';
        if (rand <= 0.9) return 'breaking';
        return 'moving';
    }

    getRandomPlatformX() {
        const padding = 20;
        return padding + Math.random() * (360 - 70 - padding * 2);
    }

    getRandomGap() {
        return 60 + Math.random() * (100 - 60);
    }

    update(playerY, deltaTime) {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏–∑–∏–∫—É –ø–ª–∞—Ç—Ñ–æ—Ä–º (–¥–≤–∏–∂—É—â–∏–µ—Å—è –∏ –ª–æ–º–∞—é—â–∏–µ—Å—è)
        this.platforms.forEach(platform => {
            platform.update(deltaTime);
        });

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º –í–í–ï–†–•
        this.generateInfinitePlatforms(playerY);
        
        return 0;
    }
    
    // –û–±–Ω–æ–≤–∏—Ç–µ –º–µ—Ç–æ–¥ generateInfinitePlatforms –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
    generateInfinitePlatforms(playerY) {
        const highestPlatform = this.getHighestPlatform();
        if (!highestPlatform) return;
        
        const currentHighestY = highestPlatform.y;
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã, –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø—Ä–∏–±–ª–∏–∑–∏–ª—Å—è –∫ —Ç–µ–∫—É—â–µ–π —Å–∞–º–æ–π –≤—ã—Å–æ–∫–æ–π
        const distanceToTop = playerY - currentHighestY;
        
        if (distanceToTop < 400) { // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –±–ª–∏–∑–∫–æ –∫ –≤–µ—Ä—Ö—É
            let currentY = this.lastGenerationHeight;
            const platformsToGenerate = 10;
            
            for (let i = 0; i < platformsToGenerate; i++) {
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è –µ—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
                if (this.platforms.length >= this.maxPlatforms) {
                    console.log('üìä Reached max platforms limit');
                    break;
                }
                
                currentY -= this.getRandomGap();
                
                // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏—Ö –ø—Ä—ã–∂–∫–æ–≤
                if (Math.abs(currentY - this.lastGenerationHeight) > 150) {
                    currentY = this.lastGenerationHeight - 100;
                }
                
                this.generatePlatform(currentY);
            }
            
            this.lastGenerationHeight = currentY;
            this.highestPoint = Math.min(this.highestPoint, currentY);
            
            console.log(`üîº Generated platforms up to Y: ${Math.round(currentY)}`);
        }
    }
    getRandomGap() {
        return 60 + Math.random() * 80; // 60-140px –º–µ–∂–¥—É –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º–∏
    }

    getRandomPlatformX() {
        const padding = 20;
        return padding + Math.random() * (360 - 70 - padding * 2);
    }

    getRandomPlatformType() {
        const rand = Math.random();
        if (this.platforms.length < 10) return 'normal'; // –ü–µ—Ä–≤—ã–µ 10 –ø–ª–∞—Ç—Ñ–æ—Ä–º - –æ–±—ã—á–Ω—ã–µ
        
        if (rand <= 0.6) return 'normal';    // 60% –æ–±—ã—á–Ω—ã–µ
        if (rand <= 0.85) return 'breaking'; // 25% –ª–æ–º–∞—é—â–∏–µ—Å—è  
        return 'moving';                     // 15% –¥–≤–∏–∂—É—â–∏–µ—Å—è
    }

    // –ó–ê–ö–û–ú–ú–ï–ù–¢–ò–†–£–ô–¢–ï –∏–ª–∏ –£–î–ê–õ–ò–¢–ï –º–µ—Ç–æ–¥ cleanupOldPlatforms
    /*
    cleanupOldPlatforms(playerY) {
        const cleanupThreshold = 800;
        
        const initialCount = this.platforms.length;
        this.platforms = this.platforms.filter(platform => {
            return platform.y < playerY + 600 + cleanupThreshold;
        });
        
        const removed = initialCount - this.platforms.length;
        if (removed > 0) {
            console.log(`üóëÔ∏è Cleaned up ${removed} platforms below Y: ${playerY + 600 + cleanupThreshold}`);
        }
        
        return removed;
    }
    */

    getHighestPlatform() {
        if (this.platforms.length === 0) return null;
        
        let highest = this.platforms[0];
        for (let i = 1; i < this.platforms.length; i++) {
            if (this.platforms[i].y < highest.y) {
                highest = this.platforms[i];
            }
        }
        return highest;
    }

    getLowestPlatform() {
        if (this.platforms.length === 0) return null;
        
        let lowest = this.platforms[0];
        for (let i = 1; i < this.platforms.length; i++) {
            if (this.platforms[i].y > lowest.y) {
                lowest = this.platforms[i];
            }
        }
        return lowest;
    }

    getPlatformsInView() {
        return this.platforms.filter(platform => 
            platform.y >= -100 && platform.y <= 700
        );
    }

    getStartPlatform() {
        if (this.platforms.length === 0) {
            console.error('‚ùå No platforms available for start position!');
            return null;
        }
        
        // –ò—â–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –±–ª–∏–∂–∞–π—à—É—é –∫ Y=500
        const targetY = 500;
        const sortedPlatforms = [...this.platforms].sort((a, b) => {
            const diffA = Math.abs(a.y - targetY);
            const diffB = Math.abs(b.y - targetY);
            return diffA - diffB;
        });
        
        const startPlatform = sortedPlatforms[0];
        console.log(`üéØ Selected start platform at Y: ${startPlatform.y}`);
        
        return startPlatform;
    }

    updateHighestPoint() {
        const highestPlatform = this.getHighestPlatform();
        if (highestPlatform) {
            this.highestPoint = Math.min(this.highestPoint, highestPlatform.y);
        }
    }

    draw(ctx, assets) {
        this.platforms.forEach(platform => {
            platform.draw(ctx, assets);
        });
        
        if (window.DEBUG_MODE) {
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(`Platforms: ${this.platforms.length}`, 10, 580);
            
            const highest = this.getHighestPlatform();
            if (highest) {
                ctx.fillText(`Highest: ${Math.round(highest.y)}`, 10, 600);
            }
        }
    }

    checkCollisions(player, currentTime) {
        for (const platform of this.platforms) {
            if (platform.collidesWith(player, currentTime)) {
                if (platform.type === 'breaking') {
                    platform.startBreaking();
                }
                return true;
            }
        }
        return false;
    }

    reset() {
        console.log('üîÑ Resetting PlatformManager');
        this.platforms = [];
        this.scrollY = 0;
        this.highestPoint = 0;
        this.totalPlatformsGenerated = 0;
        this.lastGenerationHeight = 0;
        this.generateInitialPlatforms();
    }

    validatePlatforms() {
        console.log('üîç Validating platforms...');
        
        let validCount = 0;
        let invalidCount = 0;
        
        this.platforms.forEach((platform, index) => {
            if (isNaN(platform.x) || isNaN(platform.y)) {
                console.error(`‚ùå Invalid platform ${index}: x=${platform.x}, y=${platform.y}`);
                invalidCount++;
            } else {
                validCount++;
            }
        });
        
        console.log(`‚úÖ Platform validation: ${validCount} valid, ${invalidCount} invalid`);
        
        if (invalidCount > 0) {
            console.error('‚ùå Platform validation failed!');
        }
        
        return invalidCount === 0;
    }

    getProgress() {
        return Math.max(0, 600 - this.highestPoint);
    }
    
    getDebugInfo() {
        const startPlatform = this.getStartPlatform();
        const highestPlatform = this.getHighestPlatform();
        const lowestPlatform = this.getLowestPlatform();
        const platformsInView = this.getPlatformsInView();
        
        return {
            totalPlatforms: this.platforms.length,
            platformsInView: platformsInView.length,
            platformsGenerated: this.totalPlatformsGenerated,
            highestPoint: Math.round(this.highestPoint),
            highestPlatformY: highestPlatform ? Math.round(highestPlatform.y) : 'None',
            lowestPlatformY: lowestPlatform ? Math.round(lowestPlatform.y) : 'None',
            lastGenerationHeight: Math.round(this.lastGenerationHeight),
            startPlatform: startPlatform ? {
                x: Math.round(startPlatform.x),
                y: Math.round(startPlatform.y),
                type: startPlatform.type
            } : 'Not found'
        };
    }
}

// –Ø–≤–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å—ã –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏
window.Platform = Platform;
window.PlatformManager = PlatformManager;

console.log('‚úÖ Platform classes defined');